# cloudbuild-feature.yaml
# Builds TWO images:
# 1. Python App Image (Streamlit + FastAPI) using Dockerfile
# 2. Go MCP Server Image using Dockerfile.mcp
# Deploys THREE Cloud Run services.

steps:
  # --- Step 1a: Build Python App Image ---
  - name: 'gcr.io/kaniko-project/executor:latest'
    id: Build-Python-App
    args:
      - '--destination=${_ARTIFACT_REGISTRY_REPO}/${_PYTHON_APP_IMAGE_NAME}:${SHORT_SHA}'
      - '--context=dir://.'
      - '--dockerfile=Dockerfile' # Your existing Python app Dockerfile
      - '--cache=false'

  # --- Step 1b: Build MCP Server Image ---
  - name: 'gcr.io/kaniko-project/executor:latest'
    id: Build-MCP-Server
    args:
      - '--destination=${_ARTIFACT_REGISTRY_REPO}/${_MCP_IMAGE_NAME}:${SHORT_SHA}'
      # *** Assumes github-mcp-server source is in the root context. Adjust if needed. ***
      - '--context=dir://.'
      - '--dockerfile=Dockerfile.mcp' # The new Dockerfile for MCP server
      - '--cache=false'
      # Add build-arg for GITHUB_TOKEN if needed by Dockerfile.mcp build steps
      # - '--build-arg=GITHUB_TOKEN=${_GITHUB_TOKEN}' # Example if needed during build

  # --- Step 2a: Deploy Streamlit Service ---
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: Deploy-Streamlit
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME_STREAMLIT}'
      - '--project=${_GCP_PROJECT_ID}'
      - '--image=${_ARTIFACT_REGISTRY_REPO}/${_PYTHON_APP_IMAGE_NAME}:${SHORT_SHA}' # Use Python App Image
      - '--region=${_REGION}'
      - '--platform=managed'
      - '--port=8080' # Streamlit port
      - '--allow-unauthenticated'
      # --- CORRECTED MCP_SERVER_URL construction (No '.a', uses full _REGION) --- #
      - '--set-env-vars=^##^GOOGLE_API_KEY=${_GOOGLE_API_KEY}##AGENT_MODEL_NAME=${_AGENT_MODEL_NAME}##BQ_DEFAULT_LOCATION=${_BQ_DEFAULT_LOCATION}##VM_DEFAULT_ZONE=${_VM_DEFAULT_ZONE}##VM_DEFAULT_INSTANCE_NAME=${_VM_DEFAULT_INSTANCE_NAME}##VM_DEFAULT_MACHINE_TYPE=${_VM_DEFAULT_MACHINE_TYPE}##VM_DEFAULT_SOURCE_IMAGE=${_VM_DEFAULT_SOURCE_IMAGE}##VM_DEFAULT_DISK_SIZE_GB=${_VM_DEFAULT_DISK_SIZE_GB}##VM_DEFAULT_DISK_TYPE=${_VM_DEFAULT_DISK_TYPE}##VM_DEFAULT_SUBNETWORK=${_VM_DEFAULT_SUBNETWORK}##VM_DEFAULT_SERVICE_ACCOUNT=${_VM_DEFAULT_SERVICE_ACCOUNT}##GCP_PROJECT_ID=${_GCP_PROJECT_ID}##REGION=${_REGION}##MCP_SERVER_URL=https://${_SERVICE_NAME_MCP}-${_PROJECT_HASH}.${_REGION}.run.app##GITHUB_TOKEN=${_GITHUB_TOKEN}' # Pass GitHub token too if needed by agent tools directly
      - '--command=streamlit'
      - '--args=run,ui/app.py,--server.port=8080,--server.address=0.0.0.0,--server.headless=true'
      - '--memory=1Gi'
      - '--quiet'
    waitFor: ['Build-Python-App', 'Build-MCP-Server'] # Wait for both images

  # --- Step 2b: Deploy FastAPI Service ---
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: Deploy-FastAPI
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME_FASTAPI}'
      - '--project=${_GCP_PROJECT_ID}'
      - '--image=${_ARTIFACT_REGISTRY_REPO}/${_PYTHON_APP_IMAGE_NAME}:${SHORT_SHA}' # Use Python App Image
      - '--region=${_REGION}'
      - '--platform=managed'
      - '--port=8000' # FastAPI port
      - '--session-affinity'
      - '--allow-unauthenticated'
      # --- CORRECTED MCP_SERVER_URL construction (No '.a', uses full _REGION) --- #
      - '--set-env-vars=^##^GOOGLE_API_KEY=${_GOOGLE_API_KEY}##AGENT_MODEL_NAME=${_AGENT_MODEL_NAME}##BQ_DEFAULT_LOCATION=${_BQ_DEFAULT_LOCATION}##VM_DEFAULT_ZONE=${_VM_DEFAULT_ZONE}##VM_DEFAULT_INSTANCE_NAME=${_VM_DEFAULT_INSTANCE_NAME}##VM_DEFAULT_MACHINE_TYPE=${_VM_DEFAULT_MACHINE_TYPE}##VM_DEFAULT_SOURCE_IMAGE=${_VM_DEFAULT_SOURCE_IMAGE}##VM_DEFAULT_DISK_SIZE_GB=${_VM_DEFAULT_DISK_SIZE_GB}##VM_DEFAULT_DISK_TYPE=${_VM_DEFAULT_DISK_TYPE}##VM_DEFAULT_SUBNETWORK=${_VM_DEFAULT_SUBNETWORK}##VM_DEFAULT_SERVICE_ACCOUNT=${_VM_DEFAULT_SERVICE_ACCOUNT}##GCP_PROJECT_ID=${_GCP_PROJECT_ID}##REGION=${_REGION}##MCP_SERVER_URL=https://${_SERVICE_NAME_MCP}-${_PROJECT_HASH}.${_REGION}.run.app##GITHUB_TOKEN=${_GITHUB_TOKEN}' # Pass GitHub token too if needed by agent tools directly
      - '--command=gunicorn'
      - '--args=ui.api:app,--workers=2,--worker-class=uvicorn.workers.UvicornWorker,--bind=0.0.0.0:8000'
      - '--memory=1Gi'
      - '--quiet'
    waitFor: ['Build-Python-App', 'Build-MCP-Server'] # Wait for both images

  # --- Step 2c: Deploy MCP Server Service ---
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: Deploy-MCP-Server
    entrypoint: gcloud
    args:
      - 'run'
      - 'deploy'
      - '${_SERVICE_NAME_MCP}' # New service name for MCP server
      - '--project=${_GCP_PROJECT_ID}'
      - '--image=${_ARTIFACT_REGISTRY_REPO}/${_MCP_IMAGE_NAME}:${SHORT_SHA}' # Use MCP Server Image
      - '--region=${_REGION}'
      - '--platform=managed'
      - '--port=${_MCP_SERVER_PORT}' # Port for MCP service (e.g., 8081), though the stdio CMD won't use it correctly.
      - '--allow-unauthenticated' # Adjust as needed, maybe restrict ingress later
      # --- ADD GITHUB_PERSONAL_ACCESS_TOKEN --- #
      - '--set-env-vars=^##^GITHUB_PERSONAL_ACCESS_TOKEN=${_GITHUB_TOKEN}' # MCP Server needs this token
      # The command is set by the Dockerfile's CMD. Cloud Run expects an HTTP server.
      # If the Dockerfile CMD was different (e.g., running a wrapper), specify command/args here.
      - '--memory=512Mi' # Adjust memory as needed
      - '--quiet'
    waitFor: ['Build-Python-App', 'Build-MCP-Server'] # Wait for both images

substitutions:
  _GCP_PROJECT_ID: ''
  _REGION: '' # e.g., us-central1
  _REPO_ID: ''
  _PYTHON_APP_IMAGE_NAME: 'adk-multi-agent-app' # Renamed for clarity
  _MCP_IMAGE_NAME: 'adk-mcp-server'          # New image name for MCP server
  _SERVICE_NAME_STREAMLIT: 'adk-multi-agent-streamlit'
  _SERVICE_NAME_FASTAPI: 'adk-multi-agent-api'
  _SERVICE_NAME_MCP: 'adk-multi-agent-mcp'         # New service name for MCP server
  _GOOGLE_API_KEY: ''
  _GITHUB_TOKEN: ''                            # New: GitHub Personal Access Token
  _AGENT_MODEL_NAME: ''
  _BQ_DEFAULT_LOCATION: ''
  _VM_DEFAULT_ZONE: ''
  _VM_DEFAULT_INSTANCE_NAME: ''
  _VM_DEFAULT_MACHINE_TYPE: ''
  _VM_DEFAULT_SOURCE_IMAGE: ''
  _VM_DEFAULT_DISK_SIZE_GB: ''
  _VM_DEFAULT_DISK_TYPE: ''
  _VM_DEFAULT_SUBNETWORK: ''
  _VM_DEFAULT_SERVICE_ACCOUNT: ''
  _MCP_SERVER_PORT: '8081'                     # New: Port for Cloud Run MCP service (Placeholder)
  # --- Derived variables ---
  _ARTIFACT_REGISTRY_REPO: '${_REGION}-docker.pkg.dev/${_GCP_PROJECT_ID}/${_REPO_ID}'
  # --- Variables for constructing MCP_SERVER_URL ---
  # You need the project hash. This isn't a standard substitution.
  # OPTION 1: Hardcode (or pass in) the hash if known.
  # OPTION 2: Use a script/step *after* MCP deployment to get its URL and update the other services (more complex).
  # OPTION 3: Use a predictable name + DNS mapping (most robust).
  # This example uses a placeholder - replace with your actual values or implement Option 2/3.
  _PROJECT_HASH: 'your-project-hash' # Replace with your project's hash (find in Cloud Run service URL)

options:
  logging: CLOUD_LOGGING_ONLY
  machineType: 'E2_HIGHCPU_8' # Or adjust as needed for Go build